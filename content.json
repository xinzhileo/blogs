{"meta":{"title":"胡伟煌","subtitle":"个人博客","description":"","author":"胡伟煌","url":"http://www.huweihuang.com"},"pages":[],"posts":[{"title":"异常发送邮件","slug":"异常发送邮件","date":"2019-01-12T09:00:19.691Z","updated":"2019-01-12T09:43:22.704Z","comments":true,"path":"article/异常发送邮件/","link":"","permalink":"http://www.huweihuang.com/article/异常发送邮件/","excerpt":"","text":"public class DefaultHttpExceptionHandler implements HttpExceptionHandler { private static final Logger logger = LoggerFactory.getLogger(DefaultHttpExceptionHandler.class); private static final int EXCEPTION_SWITH = PropertyUtils.getInt(&quot;exception.remind.switch&quot;, 1); private static final String EXCEPTION_PROJECT = PropertyUtils.getString(&quot;exception.remind.project&quot;, &quot;not set&quot;); private static final String EXCEPTION_PROFILE = PropertyUtils.getString(&quot;exception.remind.profile&quot;, &quot;prod&quot;); private static final String LOCAL_IP = StrUtils.getLocalHostAddress(); public DefaultHttpExceptionHandler() { } public void exceptionHandle(HttpRequest request, HttpResponse response, Exception exception) { try { SecurityUtils.getSubject().logout(); } catch (Exception var5) { ; } if (!(exception instanceof AuthenticationException) &amp;&amp; !(exception instanceof UnauthenticatedException) &amp;&amp; !(exception.getCause() instanceof AuthenticationException) &amp;&amp; !(exception.getCause() instanceof UnauthenticatedException)) { if (!(exception instanceof UnauthorizedException) &amp;&amp; !(exception.getCause() instanceof UnauthorizedException)) { if (exception instanceof FinhubException) { ResponseResultUtils.fail(response, (FinhubException)exception); } else if (exception.getCause() != null &amp;&amp; exception.getCause() instanceof FinhubException) { ResponseResultUtils.fail(response, (FinhubException)exception.getCause()); } else if (exception.getCause() != null &amp;&amp; exception.getCause() instanceof ValidateException) { ResponseResultUtils.fail(response, new FinhubException(600, exception.getCause().getMessage())); } else { FinhubLogger.error(&quot;内部错误&quot;, new Object[]{exception}); logger.error(ExceptionUtils.getErrorMessageWithNestedException(exception), exception); this.exceptionRemind(request, exception); ResponseResultUtils.exception(response); } } else { ResponseResultUtils.fail(response, new FinhubException(403)); } } else { ResponseResultUtils.fail(response, new FinhubException(401)); } } protected void exceptionRemind(HttpRequest request, Exception exception) { try { if (EXCEPTION_SWITH == 0) { return; } String url = &quot;http://mail.com/mail/inner&quot;; Map&lt;String, Object&gt; content = Maps.newLinkedHashMap(); content.put(&quot;toList&quot;, Lists.newArrayList(new String[]{&quot;rd@xxx.com&quot;})); content.put(&quot;subject&quot;, StrUtils.formatString(&quot;项目【{0}】【{1}】【{2}】发生内部错误&quot;, new Object[]{EXCEPTION_PROJECT, EXCEPTION_PROFILE, LOCAL_IP})); StringBuffer text = new StringBuffer(); text.append(&quot;requestId：&quot;).append(request.getRequestId()).append(&quot;\\n&quot;); text.append(&quot;requestURI：&quot;).append(request.getUri()).append(&quot;\\n&quot;); if (exception.getCause() != null &amp;&amp; exception.getCause() instanceof Exception) { exception = (Exception)exception.getCause(); } text.append(&quot;exception：&quot;).append(ExceptionUtils.getStackTraceAsString(exception)); content.put(&quot;text&quot;, text.toString()); HttpClientUtils.postBody(url, JSON.toJSONString(content)); } catch (Exception var6) { logger.error(&quot;发送异常邮件异常：&quot; + var6.getMessage(), var6); } } }","categories":[],"tags":[]},{"title":"Java 流式写法","slug":"Java Lambda","date":"2018-07-16T06:46:15.708Z","updated":"2018-07-16T06:50:39.044Z","comments":true,"path":"article/Java Lambda/","link":"","permalink":"http://www.huweihuang.com/article/Java Lambda/","excerpt":"","text":"本文列举了十个使用一行代码即可独立完成(不依赖其他代码)的业务逻辑，主要依赖的是Java8中的Lambda和Stream等新特性以及try-with-resources、JAXB等。 对列表/数组中的每个元素都乘以2 // Range是半开区间 int[] ia = range(1, 10).map(i -&gt; i * 2).toArray(); List&lt;Integer&gt; result = range(1, 10).map(i -&gt; i * 2).boxed().collect(toList()); 2.计算集合/数组中的数字之和 range(1, 1000).sum(); range(1, 1000).reduce(0, Integer::sum); Stream.iterate(0, i -&gt; i + 1).limit(1000).reduce(0, Integer::sum); IntStream.iterate(0, i -&gt; i + 1).limit(1000).reduce(0, Integer::sum); 3.验证字符串是否包含集合中的某一字符串 final List&lt;String&gt; keywords = Arrays.asList(&quot;brown&quot;, &quot;fox&quot;, &quot;dog&quot;, &quot;pangram&quot;); final String tweet = &quot;The quick brown fox jumps over a lazy dog. #pangram http://www.rinkworks.com/words/pangrams.shtml&quot;; keywords.stream().anyMatch(tweet::contains); keywords.stream().reduce(false, (b, keyword) -&gt; b || tweet.contains(keyword), (l, r) -&gt; l || r); 4.读取文件内容 原作者认为try with resources也是一种单行代码编程。 try (BufferedReader reader = new BufferedReader(new FileReader(&quot;data.txt&quot;))) { String fileText = reader.lines().reduce(&quot;&quot;, String::concat); } try (BufferedReader reader = new BufferedReader(new FileReader(&quot;data.txt&quot;))) { List&lt;String&gt; fileLines = reader.lines().collect(toCollection(LinkedList&lt;String&gt;::new)); } try (Stream&lt;String&gt; lines = Files.lines(new File(&quot;data.txt&quot;).toPath(), Charset.defaultCharset())) { List&lt;String&gt; fileLines = lines.collect(toCollection(LinkedList&lt;String&gt;::new)); } 5.输出歌曲《Happy Birthday to You!》 – 根据集合中不同的元素输出不同的字符串 range(1, 5).boxed().map(i -&gt; { out.print(&quot;Happy Birthday &quot;); if (i == 3) return &quot;dear NAME&quot;; else return &quot;to You&quot;; }).forEach(out::println); 6.过滤并分组集合中的数字 Map&lt;String, List&lt;Integer&gt;&gt; result = Stream.of(49, 58, 76, 82, 88, 90).collect(groupingBy(forPredicate(i -&gt; i &gt; 60, &quot;passed&quot;, &quot;failed&quot;))); 7.获取并解析xml协议的Web Service FeedType feed = JAXB.unmarshal(new URL(&quot;http://search.twitter.com/search.atom?&amp;q=java8&quot;), FeedType.class); JAXB.marshal(feed, System.out); 8.获得集合中最小/最大的数字 int min = Stream.of(14, 35, -7, 46, 98).reduce(Integer::min).get(); min = Stream.of(14, 35, -7, 46, 98).min(Integer::compare).get(); min = Stream.of(14, 35, -7, 46, 98).mapToInt(Integer::new).min(); int max = Stream.of(14, 35, -7, 46, 98).reduce(Integer::max).get(); max = Stream.of(14, 35, -7, 46, 98).max(Integer::compare).get(); max = Stream.of(14, 35, -7, 46, 98).mapToInt(Integer::new).max(); 9.并行处理 long result = dataList.parallelStream().mapToInt(line -&gt; processItem(line)).sum(); 10.集合上的各种查询(LINQ in Java) List&lt;Album&gt; albums = Arrays.asList(unapologetic, tailgates, red); //筛选出至少有一个track评级4分以上的专辑，并按照名称排序后打印出来。 albums.stream() .filter(a -&gt; a.tracks.stream().anyMatch(t -&gt; (t.rating &gt;= 4))) .sorted(comparing(album -&gt; album.name)) .forEach(album -&gt; System.out.println(album.name)); //合并所有专辑的track List&lt;Track&gt; allTracks = albums.stream() .flatMap(album -&gt; album.tracks.stream()) .collect(toList()); //根据track的评分对所有track分组 Map&lt;Integer, List&lt;Track&gt;&gt; tracksByRating = allTracks.stream() .collect(groupingBy(Track::getRating));","categories":[],"tags":[]},{"title":"各个App薅流量(联通卡)","slug":"薅流量","date":"2018-07-04T09:27:04.603Z","updated":"2018-07-04T09:55:52.089Z","comments":true,"path":"article/薅流量/","link":"","permalink":"http://www.huweihuang.com/article/薅流量/","excerpt":"","text":"京东领流量 滴滴领流量 支付宝领流量 飞猪领流量 饿了么流量 菜鸟裹裹兑换流量","categories":[],"tags":[]},{"title":"SQL慢查询","slug":"SQL慢查询","date":"2018-07-04T09:24:28.936Z","updated":"2018-07-04T09:24:28.936Z","comments":true,"path":"article/SQL慢查询/","link":"","permalink":"http://www.huweihuang.com/article/SQL慢查询/","excerpt":"","text":"id : 查询序列号为1。select_type : 查询类型是简单查询，简单的select语句没有union和子查询。table : 表是 itdragon_order_list。partitions : 没有分区。type : 连接类型，all表示采用全表扫描的方式。possible_keys : 可能用到索引为null。key : 实际用到索引是null。key_len : 索引长度当然也是null。ref : 没有哪个列或者参数和key一起被使用。Extra : 使用了where查询。","categories":[],"tags":[]},{"title":"Lambda不同写法","slug":"Lambda不同写法","date":"2018-07-04T09:22:30.392Z","updated":"2018-09-10T05:53:49.019Z","comments":true,"path":"article/Lambda不同写法/","link":"","permalink":"http://www.huweihuang.com/article/Lambda不同写法/","excerpt":"","text":"/**获取单词，并且去重**/ List&lt;String&gt; list = Arrays.asList(&quot;hello welcome&quot;, &quot;world hello&quot;, &quot;hello world&quot;, &quot;hello world welcome&quot;); //map和flatmap的区别 list.stream().map(item -&gt; Arrays.stream(item.split(&quot; &quot;))).distinct().collect(Collectors.toList()).forEach(System.out::println); System.out.println(&quot;---------- &quot;); list.stream().flatMap(item -&gt; Arrays.stream(item.split(&quot; &quot;))).distinct().collect(Collectors.toList()).forEach(System.out::println); //实际上返回的类似是不同的 List&lt;Stream&lt;String&gt;&gt; listResult = list.stream().map(item -&gt; Arrays.stream(item.split(&quot; &quot;))).distinct().collect(Collectors.toList()); List&lt;String&gt; listResult2 = list.stream().flatMap(item -&gt; Arrays.stream(item.split(&quot; &quot;))).distinct().collect(Collectors.toList()); System.out.println(&quot;---------- &quot;); //也可以这样 list.stream().map(item -&gt; item.split(&quot; &quot;)).flatMap(Arrays::stream).distinct().collect(Collectors.toList()).forEach(System.out::println); System.out.println(&quot;================================================&quot;); /**相互组合**/ List&lt;String&gt; list2 = Arrays.asList(&quot;hello&quot;, &quot;hi&quot;, &quot;你好&quot;); List&lt;String&gt; list3 = Arrays.asList(&quot;zhangsan&quot;, &quot;lisi&quot;, &quot;wangwu&quot;, &quot;zhaoliu&quot;); list2.stream().map(item -&gt; list3.stream().map(item2 -&gt; item + &quot; &quot; + item2)).collect(Collectors.toList()).forEach(System.out::println); list2.stream().flatMap(item -&gt; list3.stream().map(item2 -&gt; item + &quot; &quot; + item2)).collect(Collectors.toList()).forEach(System.out::println); //实际上返回的类似是不同的 List&lt;Stream&lt;String&gt;&gt; list2Result = list2.stream().map(item -&gt; list3.stream().map(item2 -&gt; item + &quot; &quot; + item2)).collect(Collectors.toList()); List&lt;String&gt; list2Result2 = list2.stream().flatMap(item -&gt; list3.stream().map(item2 -&gt; item + &quot; &quot; + item2)).collect(Collectors.toList());","categories":[],"tags":[]},{"title":"SQL注意事项","slug":"SQL注意事项","date":"2018-07-04T09:22:30.392Z","updated":"2018-07-04T09:23:44.758Z","comments":true,"path":"article/SQL注意事项/","link":"","permalink":"http://www.huweihuang.com/article/SQL注意事项/","excerpt":"","text":"通过explain的参数介绍，我们可以得知： 表的读取顺序(id) 数据读取操作的操作类型(type) 哪些索引被实际使用(key) 表之间的引用(ref) 每张表有多少行被优化器查询(rows) 性能下降的原因从程序员的角度 查询语句写的不好 没建索引，索引建的不合理或索引失效 关联查询有太多的join 从服务器的角度 服务器磁盘空间不足 服务器调优配置参数设置不合理 总结 索引是排好序且快速查找的数据结构。其目的是为了提高查询的效率。 创建索引后，查询数据变快，但更新数据变慢。 性能下降的原因很可能是索引失效导致。 索引创建的原则，经常查询的字段适合创建索引，频繁需要更新的数据不适合创建索引。 索引字段频繁更新，或者表数据物理删除容易造成索引失效。 擅用 explain 分析sql语句 除了优化sql语句外，还可以优化表的设计。如尽量做成单表查询，减少表之间的关联。设计归档表等。","categories":[],"tags":[]},{"title":"基础类型转换","slug":"ObjUtils","date":"2018-07-04T09:22:30.392Z","updated":"2018-12-24T08:03:10.764Z","comments":true,"path":"article/ObjUtils/","link":"","permalink":"http://www.huweihuang.com/article/ObjUtils/","excerpt":"","text":"import org.apache.commons.collections4.MapUtils; import org.apache.commons.lang3.ArrayUtils; import org.apache.commons.lang3.StringUtils; import org.apache.commons.lang3.builder.ToStringBuilder; import org.dozer.DozerBeanMapper; import org.dozer.Mapper; import java.math.BigDecimal; import java.util.ArrayList; import java.util.Collection; import java.util.List; import java.util.Map; public class ObjUtils { private static final String NULL_VALUE = &quot;NULL&quot;; private static final String EMPTY_VALUE = &quot;&quot;; private static final String COMMA = &quot;,&quot;; private static final String BOOLEAN_TRUE = &quot;TRUE&quot;; private static final String BOOLEAN_FALSE = &quot;FALSE&quot;; private static final String BOOLEAN_T = &quot;T&quot;; private static final String BOOLEAN_F = &quot;F&quot;; private static final String BOOLEAN_Y = &quot;Y&quot;; private static final String BOOLEAN_N = &quot;N&quot;; private static final String BOOLEAN_1 = &quot;1&quot;; private static final String BOOLEAN_0 = &quot;0&quot;; private static Mapper mapper; public static &lt;T&gt; T ifNull(T object, T defaultValue) { return object == null ? defaultValue : object; } public static boolean isNull(Object value) { if (value == null) { return true; } else if (value instanceof String &amp;&amp; NULL_VALUE.equalsIgnoreCase((String) value)) { return true; } return false; } public static boolean isEmpty(Object value) { if (value == null) { return true; } else if (value instanceof String) { if (StringUtils.isEmpty((String) value) || NULL_VALUE.equalsIgnoreCase((String) value)) { return true; } } else if (value instanceof Collection &amp;&amp; CollectionUtils.isEmpty((Collection) value)) { return true; } else if (value instanceof Map &amp;&amp; MapUtils.isEmpty((Map) value)) { return true; } return false; } public static boolean isNotEmpty(Object value) { return !isEmpty(value); } public static &lt;T&gt; boolean isEmpty(final T[] array) { return ArrayUtils.isEmpty(array); } public static &lt;T&gt; boolean isNotEmpty(final T[] array) { return ArrayUtils.isNotEmpty(array); } public static boolean isBlank(Object value) { if (value == null) { return true; } else if (value instanceof String) { if (StringUtils.isBlank((String) value) || NULL_VALUE.equalsIgnoreCase((String) value)) { return true; } } return false; } public static boolean isNotBlank(Object value) { return !isBlank(value); } public static String toString(Object obj) { if (obj == null) { return null; } if (obj instanceof String) { return (String) obj; } return obj.toString(); } public static String toString(Object obj, String defaultValue) { return ifNull(toString(obj), defaultValue); } public static String toStringTrim(Object obj) { String value = toString(obj); if (value == null) { return null; } return value.trim(); } public static String toStringTrim(Object obj, String defaultValue) { return ifNull(toStringTrim(obj), defaultValue); } public static Integer toInteger(Object obj) { if (isEmpty(obj)) { return null; } if (obj instanceof Integer) { return (Integer) obj; } if (obj instanceof Number) { return ((Number) obj).intValue(); } // 处理字符串值 String strValue = obj.toString().trim(); // 处理千分位 if (strValue.contains(COMMA)) { strValue = strValue.replaceAll(COMMA, EMPTY_VALUE); } try { return new BigDecimal(strValue).intValue(); } catch (Exception e) { } return null; } public static Integer toInteger(Object obj, Integer defaultValue) { return ifNull(toInteger(obj), defaultValue); } public static Long toLong(Object obj) { if (isEmpty(obj)) { return null; } if (obj instanceof Long) { return (Long) obj; } if (obj instanceof Number) { return ((Number) obj).longValue(); } // 处理字符串值 String strValue = obj.toString().trim(); // 处理千分位 if (strValue.contains(COMMA)) { strValue = strValue.replaceAll(COMMA, EMPTY_VALUE); } try { return new BigDecimal(strValue).longValue(); } catch (Exception e) { } return null; } public static Long toLong(Object obj, Long defaultValue) { return ifNull(toLong(obj), defaultValue); } public static BigDecimal toBigDecimal(Object obj) { if (isEmpty(obj)) { return null; } if (obj instanceof BigDecimal) { return (BigDecimal) obj; } // 处理字符串值 String strValue = obj.toString().trim(); // 处理千分位 if (strValue.contains(COMMA)) { strValue = strValue.replaceAll(COMMA, EMPTY_VALUE); } try { return new BigDecimal(strValue); } catch (Exception e) { } return null; } public static BigDecimal toBigDecimal(Object obj, BigDecimal defaultValue) { return ifNull(toBigDecimal(obj), defaultValue); } public static Boolean toBoolean(Object obj) { if (isEmpty(obj)) { return null; } if (obj instanceof Boolean) { return (Boolean) obj; } if (obj instanceof Number) { return Boolean.valueOf(((Number) obj).intValue() == 1); } // 处理字符串值 String strValue = obj.toString().trim(); if (BOOLEAN_TRUE.equalsIgnoreCase(strValue) || BOOLEAN_T.equalsIgnoreCase(strValue) || BOOLEAN_Y.equalsIgnoreCase(strValue) || BOOLEAN_1.equals(strValue)) { return Boolean.TRUE; } if (BOOLEAN_FALSE.equalsIgnoreCase(strValue) || BOOLEAN_F.equalsIgnoreCase(strValue) || BOOLEAN_N.equalsIgnoreCase(strValue) || BOOLEAN_0.equals(strValue)) { return Boolean.FALSE; } return null; } public static Boolean toBoolean(Object obj, Boolean defaultValue) { return ifNull(toBoolean(obj), defaultValue); } public static boolean toboolean(Object obj) { return toBoolean(obj, false); } public static Mapper getMapper() { if (mapper == null) { synchronized (ObjUtils.class) { if (mapper == null) { mapper = new DozerBeanMapper(); } } } return mapper; } public static void map(Object source, Object destination) { getMapper().map(source, destination); } public static &lt;T&gt; T map(Object source, Class&lt;T&gt; destinationClass) { return getMapper().map(source, destinationClass); } public static String prop2String(Object obj) { if (obj == null) { return null; } return ToStringBuilder.reflectionToString(obj); } public static Integer[] string2IntAry(String str, String separatorChars, Integer defaultValue) { if (isBlank(str)) { return null; } String[] strAry = StringUtils.split(str, separatorChars); Integer[] intAry = new Integer[strAry.length]; for (int i = 0; i &lt; strAry.length; i++) { intAry[i] = toInteger(strAry[i], defaultValue); } return intAry; } public static List&lt;Integer&gt; string2IntList(String str, String separatorChars, Integer defaultValue) { if (isBlank(str)) { return new ArrayList&lt;Integer&gt;(1); } String[] strAry = StringUtils.split(str, separatorChars); List&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;(strAry.length); for (int i = 0; i &lt; strAry.length; i++) { intList.add(toInteger(strAry[i], defaultValue)); } return intList; } public static Long[] string2LongAry(String str, String separatorChars, Long defaultValue) { if (isBlank(str)) { return null; } String[] strAry = StringUtils.split(str, separatorChars); Long[] longAry = new Long[strAry.length]; for (int i = 0; i &lt; strAry.length; i++) { longAry[i] = toLong(strAry[i], defaultValue); } return longAry; } public static List&lt;Long&gt; string2LongList(String str, String separatorChars, Long defaultValue) { if (isBlank(str)) { return new ArrayList&lt;Long&gt;(1); } String[] strAry = StringUtils.split(str, separatorChars); List&lt;Long&gt; longList = new ArrayList&lt;Long&gt;(strAry.length); for (int i = 0; i &lt; strAry.length; i++) { longList.add(toLong(strAry[i], defaultValue)); } return longList; } }","categories":[],"tags":[]},{"title":"JsonUtils工具","slug":"JsonUtils工具","date":"2018-07-04T06:36:36.743Z","updated":"2018-07-04T06:38:06.435Z","comments":true,"path":"article/JsonUtils工具/","link":"","permalink":"http://www.huweihuang.com/article/JsonUtils工具/","excerpt":"","text":"Json 转换为Model,采用ObjectMapper作为映射 import com.fasterxml.jackson.annotation.JsonInclude.Include; import com.fasterxml.jackson.databind.DeserializationFeature; import com.fasterxml.jackson.databind.JavaType; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.PropertyNamingStrategy; import java.io.IOException; import java.text.SimpleDateFormat; import java.util.Collection; import java.util.Map; import org.apache.commons.lang3.StringUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class JsonUtils { private static Logger logger = LoggerFactory.getLogger(JsonUtils.class); private static ObjectMapper defaultMapper = new ObjectMapper(); private static ObjectMapper snakeMapper; public JsonUtils() { } public static String toJson(Object obj) { try { return obj == null ? null : defaultMapper.writeValueAsString(obj); } catch (IOException var2) { logger.error(&quot;[writeValueAsString]：&quot; + var2.getMessage(), var2); return null; } } public static String toJsonSnake(Object obj) { try { return obj == null ? null : snakeMapper.writeValueAsString(obj); } catch (IOException var2) { logger.error(&quot;[writeValueAsString]：&quot; + var2.getMessage(), var2); return null; } } public static &lt;T&gt; T toObj(String json, Class&lt;T&gt; clazz) { try { return StringUtils.isEmpty(json) ? null : defaultMapper.readValue(json, clazz); } catch (IOException var3) { logger.error(&quot;[readValue]：&quot; + var3.getMessage(), var3); return null; } } public static &lt;T&gt; T toObjSnake(String json, Class&lt;T&gt; clazz) { try { return StringUtils.isEmpty(json) ? null : snakeMapper.readValue(json, clazz); } catch (IOException var3) { logger.error(&quot;[readValue]：&quot; + var3.getMessage(), var3); return null; } } public static &lt;T&gt; T toObj(String json, Class&lt;? extends Collection&gt; collectionClass, Class&lt;?&gt; elementClass) { try { if (StringUtils.isEmpty(json)) { return null; } else { JavaType javaType = defaultMapper.getTypeFactory().constructCollectionType(collectionClass, elementClass); return defaultMapper.readValue(json, javaType); } } catch (IOException var4) { logger.error(&quot;[toObj]&quot; + var4.getMessage(), var4); return null; } } public static &lt;T&gt; T toObj(String json, Class&lt;? extends Map&gt; mapClass, Class&lt;?&gt; keyClass, Class&lt;?&gt; valueClass) { try { if (StringUtils.isEmpty(json)) { return null; } else { JavaType javaType = defaultMapper.getTypeFactory().constructMapType(mapClass, keyClass, valueClass); return defaultMapper.readValue(json, javaType); } } catch (IOException var5) { logger.error(&quot;[toObj]&quot; + var5.getMessage(), var5); return null; } } public static String formatJson(String json) { try { if (json == null) { return null; } else { Object obj = defaultMapper.readValue(json, Object.class); return defaultMapper.writerWithDefaultPrettyPrinter().writeValueAsString(obj); } } catch (Exception var2) { logger.error(&quot;[formatJson]：&quot; + var2.getMessage(), var2); return json; } } static { defaultMapper.setSerializationInclusion(Include.NON_NULL); defaultMapper.setDateFormat(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;)); defaultMapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); snakeMapper = new ObjectMapper(); snakeMapper.setSerializationInclusion(Include.NON_NULL); snakeMapper.setDateFormat(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;)); snakeMapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); snakeMapper.setPropertyNamingStrategy(PropertyNamingStrategy.CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES); } }","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.huweihuang.com/tags/Java/"}]},{"title":"Lambda表达式","slug":"Lambda表达式","date":"2018-07-04T06:32:02.720Z","updated":"2018-07-04T06:35:36.467Z","comments":true,"path":"article/Lambda表达式/","link":"","permalink":"http://www.huweihuang.com/article/Lambda表达式/","excerpt":"","text":"1.List 数组steam 处理： List&lt;Integer&gt; nums = Lists.newArrayList(1,1,null,2,3,4,null,5,6,7,8,9,10); System.out.println(“求和：”+nums .stream()//转成Stream .filter(team -&gt; team!=null)//过滤 .distinct()//去重 .mapToInt(num-&gt;num*2)//map操作 .skip(2)//跳过前2个元素 .limit(4)//限制取前4个元素 .peek(System.out::println)//流式处理对象函数 .sum()); 2.Lamda 求最小、求和等 // 求最小年龄 Optional&lt;Student&gt; olderStudent3 = students.stream().collect(Collectors.minBy(Comparator.comparing(Student::getAge))); //求年龄总和 int totalAge4 = students.stream().collect(Collectors.summingInt(Student::getAge)); String names = students.stream().map(Student::getName).collect(Collectors.joining(“, “)); // 输出：孔明, 伯约, 玄德, 云长, 翼德, 元直, 奉孝, 仲谋, 鲁肃, 丁奉 java8还提供了parallelStream()来启动并行流式处理 3.分页 int totalPage = (int) (total % pageSize == 0 ? total / pageSize : (total / pageSize + 1)); 4.生成一个范围的随机数 int randNumber = rand.nextInt(MAX - MIN + 1) + MIN 5. Area city = areaList.stream() .filter(area -&gt; AreaTypeEnums.City.equals(area.getAreaType())) .findFirst() .orElse(null); 个位 143%10=3 十位 143/10%10=4 百位 143/100 =1 6. Lambda表达式 public static Predicate&lt;String&gt; checkIfStartsWith(final String letter) { return name -&gt; name.startsWith(letter); } final long countFriendsStartN = friends.stream() .filter(checkIfStartsWith(“N”)).count(); final long countFriendsStartB = friends.stream() .filter(checkIfStartsWith(“B”)).count();","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.huweihuang.com/tags/Java/"}]},{"title":"善良","slug":"善良","date":"2018-07-04T04:03:30.213Z","updated":"2018-07-04T04:07:10.933Z","comments":true,"path":"article/善良/","link":"","permalink":"http://www.huweihuang.com/article/善良/","excerpt":"","text":"如果你的道德观念不是源于你自己对自己的要求，而来自对他人的迎合、对自身利益的计算、对自私自爱等欲望的满足，那么这些“他律”支配的行为通通都称不上真正的道德，充其量是一种“伪善”。 别人说的话，不要轻易相信，要学会印证。","categories":[],"tags":[]},{"title":"认知","slug":"hello-world","date":"2018-07-04T03:20:36.525Z","updated":"2018-07-04T04:34:49.499Z","comments":true,"path":"article/hello-world/","link":"","permalink":"http://www.huweihuang.com/article/hello-world/","excerpt":"","text":"当我们决定做任何事之前，我们是不是早就知道我们将要做出的决定呢？比如说当我们将要见一个陌生人，我们对这个人的第一印象是在接触之后形成，还是在见面之前听他人描述这个人时就已经形成呢？ 当我们进行重大事务的决策时，我们总会认为我们的决定是经过自己的深思熟虑而做出的，但是事实真的如此么？ 我们每天都见到不同的人，遇见不同的事，我们都认为自己有一个“开放包容”的心，但是我们的本能，却让这“开放包容”变得很难完全实现。 因为不管有意识无意识，至少在最初阶段，我们都会从本能地将不符合或不支持我们自己观点的信息筛选排除。这就是我们常说的认知偏差。 而这些认知偏差，影响着我们的生活中的方方面面，金融，健康，政治，科学等等，都无法避免这些认知偏差。","categories":[],"tags":[]}]}